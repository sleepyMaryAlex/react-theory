# ?useLayoutEffect

Сигнатура идентична `useEffect`.

`useEffect` запускается только после того, как браузер нарисовал изменения DOM. В 99% случаев это то, что вы хотите использовать. В отличие от `useEffect`, функция, переданная хуку `useLayoutEffect`, запускается синхронно после всех мутаций DOM. Проще говоря, `useLayoutEffect` на самом деле все равно, нарисовал ли браузер изменения DOM или нет. Он запускает функцию сразу после вычисления мутаций DOM.

Когда в компоненте имеется более одного вызова `useEffect`, порядок вызовов эффектов сохраняется. Срабатывает первый, затем второй, и последовательность продолжается. А что произойдет, если второй `useEffect` заменить на `useLayoutEffect`? Несмотря на то, что `useLayoutEffect` находится после `useEffect`, `useLayoutEffect` срабатывает первым!

~~~
function App() {
  useEffect(() => {
    console.log('useEffect')
  }, []);

  useLayoutEffect(() => {
    console.log('useLayoutEffect')
  }, []);

  return (
    <div>
      <button>Click</button>
    </div>
  );
}

// useLayoutEffect
// useEffect
~~~

Хук `useLayoutEffect` следует использовать, когда ваш компонент мерцает при обновлении состояния, что означает, что он сначала рендерится в частично готовом состоянии, а затем сразу же повторно рендерится в своем конечном состоянии.

Например, если ваш эффект мутирует DOM (через `ref` узла DOM) и мутация DOM изменит внешний вид узла DOM между моментом его рендеринга и моментом его изменения вашим эффектом.

Это может быть полезно, если вам нужно получить положение прокрутки или другие стили для элемента, а затем внести изменения DOM или запустить синхронный повторный рендеринг путем обновления состояния. Ваш код запускается сразу после обновления DOM, но до того, как браузер сможет «отрисовать» эти изменения. Что касается планирования, это работает так же, как `componentDidMount` и `componentDidUpdate`.

Теперь сравним `useLayoutEffect` и `useEffect` на примере:

~~~
function App() {
  const [value, setValue] = useState(0);

  useEffect(() => {
    if (value === 0) {
      let num = value;
      for (let i = 0; i < 1000000000; i++) {
        num += i;
      }
      setValue(num);
    }
  }, [value]);

  console.log("render", value);

  return <button onClick={() => setValue(0)}>Number: {value}</button>;
}
~~~

Когда пользователь нажимает кнопку, значение обновляется до `0`. Внутри `useEffect` мы проверяем значение, и если оно равно `0`, оно меняет значение с `0` на случайное число. В этом примере компонент отображается дважды, но значение обновляется в браузере только один раз. Вы можете видеть мерцание при использовании `useEffect`.

Давайте заменим `useEffect` на `useLayoutEffect`. Несмотря на то, что компонент визуализируется дважды, версия с `useLayoutEffect` не имеет мерцания.

### Ловушка

`useLayoutEffect` может повредить производительности. Предпочитайте `useEffect` когда это возможно. Код внутри `useLayoutEffect` и все обновления состояния, запланированные из него, блокируют перерисовку экрана браузером. При чрезмерном использовании это замедляет работу вашего приложения.
