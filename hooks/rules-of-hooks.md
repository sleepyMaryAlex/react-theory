# ?Rules of hooks

_Хуки_ — нововведение в React 16.8, которое позволяет использовать состояние и другие возможности React без написания классов. Хуки — функции, начинающиеся с `use`.

Хук — это специальная функция, которая позволяет «подцепиться» к возможностям React. Хуки предоставляют более прямой доступ к API уже знакомых вам понятий: пропсов, состояния, контекста, рефов, и жизненного цикла. Можно использовать хуки в новом коде параллельно с классами. Хуки не работают внутри классов — они дают вам возможность использовать React без классов.

Хуки — это функции JavaScript, которые налагают два дополнительных правила:

1. Хуки следует вызывать только на верхнем уровне. Не вызывайте хуки внутри циклов, условий или вложенных функций. Исполнение этого правила гарантирует, что хуки вызываются в одинаковой последовательности при каждом рендере компонента. Это позволит React правильно сохранять состояние хуков между множественными вызовами `useState` и `useEffect`.
2. Хуки следует вызывать только из функциональных компонентов React. Не вызывайте хуки из обычных JavaScript-функций. Есть только одно исключение, откуда можно вызывать хуки — это ваши пользовательские хуки.

Есть плагин для ESLint `eslint-plugin-react-hooks`, который принуждает к соблюдению этих двух правил.

~~~
npm install eslint-plugin-react-hooks --save-dev
~~~

Конфигурация ESLint:

~~~
{
  "plugins": [
    // ...
    "react-hooks"
  ],
  "rules": {
    // ...
    "react-hooks/rules-of-hooks": "error", // Проверяем правила хуков
    "react-hooks/exhaustive-deps": "warn" // Проверяем зависимости эффекта
  }
}
~~~

Хуки состояния или эффектов в одном и том же компоненте можно использовать многократно.

~~~
function Form() {
  const [name, setName] = useState('Мэри');

  useEffect(function persistForm() {
    localStorage.setItem('formData', name);
  });

  const [surname, setSurname] = useState('Поппинс');

  useEffect(function updateTitle() {
    document.title = name + ' ' + surname;
  });
}
~~~

Итак, как же React сопоставляет переменные состояния с вызовами `useState`? Ответ таков: React полагается на порядок вызова хуков.

~~~
// Первый рендер
useState('Мэри')           // 1. Инициализируем переменную name значением 'Мэри'
useEffect(persistForm)     // 2. Добавляем эффект для сохранения данных формы
useState('Поппинс')        // 3. Инициализируем переменную surname значением 'Поппинс'
useEffect(updateTitle)     // 4. Добавляем эффект для обновления заголовка страницы

// Второй рендер
useState('Мэри')           // 1. Читаем переменную состояния name (аргумент игнорируется)
useEffect(persistForm)     // 2. Заменяем эффект сохранения данных формы
useState('Поппинс')        // 3. Читаем переменную состояния surname (аргумент игнорируется)
useEffect(updateTitle)     // 4. Заменяем эффект обновления заголовка страницы
~~~

До тех пор пока порядок вызова хуков одинаков в каждом рендере, React может сопоставить некое внутреннее состояние с каждым из них. Но что случится, если мы поместим вызов хука (например, эффект `persistForm`) внутрь условного оператора?

~~~
if (name !== "") {
  useEffect(function persistForm() {
    localStorage.setItem("formData", name);
  });
}
~~~

Условие `name !== ""` равняется `true` при первом рендере, поэтому хук выполняется. Тем не менее, при следующем рендере пользователь может обратить это условие в `false`, очистив поля формы. Теперь во время рендера хук будет пропущен и порядок вызовов хуков изменится.

~~~
useState('Мэри')           // 1. Читаем переменную состояния name (аргумент игнорируется)
// useEffect(persistForm)  // Хук пропускается!
useState('Поппинс')        // 2 (но ранее был 3). Ошибка при чтении переменной состояния surname
useEffect(updateTitle)     // 3 (но ранее был 4). Ошибка при замене эффекта
~~~
