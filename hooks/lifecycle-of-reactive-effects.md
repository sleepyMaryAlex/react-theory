# ?Lifecycle of reactive effects

Жизненный цикл эффектов отличается от жизненного цикла компонентов. Компоненты могут монтироваться, обновляться или размонтироваться. Эффект может делать только две вещи: начать что-то синхронизировать, а позже остановить синхронизацию. Этот цикл может повторяться несколько раз, если ваш эффект зависит от пропсов и состояния, которые меняются со временем.

React предоставляет правило линтера, чтобы проверить, правильно ли вы указали зависимости вашего эффекта. Это позволяет синхронизировать ваш эффект с последними пропсами и состоянием.

### Жизненный цикл эффекта

Интуитивно вы можете подумать, что React начнет синхронизацию, когда ваш компонент монтируется, и прекратит синхронизацию, когда ваш компонент размонтируется. Однако это не конец истории! Иногда также может быть необходимо запускать и останавливать синхронизацию несколько раз, пока компонент остается смонтированным.

> Некоторые Эффекты вообще не возвращают функцию очистки. Чаще всего вы захотите вернуть ее, но если вы этого не сделаете, React будет вести себя так, как если бы вы вернули пустую функцию очистки.

### Каждый Эффект представляет собой отдельный процесс синхронизации

Не добавляйте в свой Эффект несвязанную логику только потому, что эта логика должна выполняться одновременно с уже написанным вами Эффектом.

Каждый Эффект в вашем коде должен представлять собой отдельный и независимый процесс синхронизации.

С другой стороны, если вы разделите связную часть логики на отдельные Эффекты, код может выглядеть «чище», но его будет сложнее поддерживать. Вот почему вы должны думать о том, одинаковы ли процессы или они разные, а не о том, выглядит ли код чище.

### Эффекты «реагируют» на реактивные значения

Ваш Эффект считывает две переменные (`serverUrl` и `roomId`), но вы указали только `roomId` как зависимость:

~~~
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}
~~~

Почему `serverUrl` не должен быть зависимостью?

Это связано с тем, что `serverUrl` никогда не меняется из-за повторного рендеринга. Это всегда одно и то же, независимо от того, сколько раз компонент перерисовывается и почему. Поскольку `serverUrl` никогда не меняется, не имеет смысла указывать его как зависимость. В конце концов, зависимости делают что-то только тогда, когда они меняются с течением времени!

С другой стороны, `roomId` может быть другим при повторном рендеринге. Пропсы, состояние и другие значения, объявленные внутри компонента, являются реактивными, поскольку они вычисляются во время рендеринга и участвуют в потоке данных React.

##### Все переменные, объявленные в теле компонента, являются реактивными.

Пропсы и состояние — не единственные реактивные значения. Значения, которые вы вычисляете из них, также являются реактивными. Если свойства или состояние изменятся, ваш компонент будет перерендерен, и значения, вычисленные из них, также изменятся. Вот почему все переменные из тела компонента, используемые Эффектом, должны быть в списке зависимостей Эффекта.

Если ваш линтер настроен для React, он проверит, что каждое реактивное значение, используемое вашим кодом Effect, объявлено как его зависимость.

В некоторых случаях React знает, что значение никогда не меняется, даже если оно объявлено внутри компонента. Например, функция `set`, возвращаемая из `useState`, и объект `ref`, возвращаемый `useRef`, являются стабильными — они гарантированно не изменятся при повторном рендеринге. Стабильные значения не реактивны, поэтому вы можете исключить их из списка. Включать их разрешено: они не изменятся, так что не беда.

### Что делать, если вы не хотите повторно синхронизировать

Вы можете «доказать» линтеру, что эти значения не являются реактивными значениями, т. е. что они не могут измениться в результате повторного рендеринга. Например, если `serverUrl` и `roomId` не зависят от рендеринга и всегда имеют одинаковые значения, их можно переместить за пределы компонента. Теперь они не должны быть зависимостями:

~~~
const serverUrl = 'https://localhost:1234'; // serverUrl is not reactive
const roomId = 'general'; // roomId is not reactive

function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []); // ✅ All dependencies declared
  // ...
}
~~~

Вы также можете переместить их внутрь Эффекта. Они не рассчитываются во время рендеринга, поэтому не являются реактивными:

~~~
function ChatRoom() {
  useEffect(() => {
    const serverUrl = 'https://localhost:1234'; // serverUrl is not reactive
    const roomId = 'general'; // roomId is not reactive
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []); // ✅ All dependencies declared
  // ...
}
~~~

Вы не можете «выбрать» свои зависимости. Ваши зависимости должны включать каждое реактивное значение, которое вы читаете в файле Effect. Линтер обеспечивает это. Иногда это может привести к таким проблемам, как бесконечные циклы и слишком частая повторная синхронизация эффекта. Не устраняйте эти проблемы путем подавления линтера! Вот что можно попробовать вместо этого:

* Убедитесь, что ваш Эффект представляет собой независимый процесс синхронизации. Если ваш Эффект ничего не синхронизирует, он может быть ненужным. Если он синхронизирует несколько независимых вещей, разделите его.

* Не полагайтесь на объекты и функции как на зависимости. Если вы создаете объекты и функции во время рендеринга, а затем считываете их из Эффекта, они будут разными при каждом рендеринге. Это приведет к повторной синхронизации вашего Эффекта каждый раз.

### Ловушка

Линтер — ваш друг, но его возможности ограничены. Линтер знает только, когда зависимости неверны. Он не знает, как лучше всего решить каждый случай. Если линтер предлагает зависимость, но ее добавление вызывает зацикливание, это не значит, что линтер следует игнорировать. Вам нужно изменить код внутри (или снаружи) Эффекта, чтобы это значение не было реактивным и не должно было быть зависимостью.

Если у вас есть существующая кодовая база, у вас могут быть некоторые Эффекты, которые подавляют линтер, например:

~~~
useEffect(() => {
  // ...
  // 🔴 Avoid suppressing the linter like this:
  // eslint-ignore-next-line react-hooks/exhaustive-deps
}, []);
~~~
