# ?createAsyncThunk

A function that accepts a Redux action type string and a callback function that should return a promise.

Redux Toolkit's RTK Query data fetching API is a purpose built data fetching and caching solution for Redux apps, and can eliminate the need to write any `thunks` or `reducers` to manage data fetching.

Sample usage:

~~~
import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import { userAPI } from "./userAPI";

// First, create the thunk
const fetchUserById = createAsyncThunk(
  "users/fetchByIdStatus",
  async (userId: number, thunkAPI) => {
    const response = await userAPI.fetchById(userId);
    return response.data;
  }
);

interface UsersState {
  entities: [];
  loading: "idle" | "pending" | "succeeded" | "failed";
}

const initialState = {
  entities: [],
  loading: "idle",
} as UsersState;

// Then, handle actions in your reducers:
const usersSlice = createSlice({
  name: "users",
  initialState,
  reducers: {
    // standard reducer logic, with auto-generated action types per reducer
  },
  extraReducers: (builder) => {
    // Add reducers for additional action types here, and handle loading state as needed
    builder.addCase(fetchUserById.fulfilled, (state, action) => {
      // Add user to the state array
      state.entities.push(action.payload);
    });
  },
});

// Later, dispatch the thunk as needed in the app
dispatch(fetchUserById(123));
~~~

### Parameters

`createAsyncThunk` accepts three parameters:

1. `type`. A string that will be used to generate additional Redux action type constants, representing the lifecycle of an async request:

For example, a type argument of `'users/requestStatus'` will generate these action types:

* `pending: 'users/requestStatus/pending'`
* `fulfilled: 'users/requestStatus/fulfilled'`
* `rejected: 'users/requestStatus/rejected'`

2. `payloadCreator`. A callback function that should return a promise containing the result of some asynchronous logic.

The `payloadCreator` function will be called with two arguments:

* `arg`: a single value, containing the first parameter that was passed to the thunk action creator when it was dispatched.
* `thunkAPI`: an object containing all of the parameters that are normally passed to a Redux thunk function, as well as additional options.

3. `options`. An object with optional fields.

### Return Value

`createAsyncThunk` returns a standard Redux thunk action creator. The thunk action creator function will have plain action creators for the `pending`, `fulfilled`, and `rejected` cases attached as nested fields.

### Handling Thunk Results

The thunks generated by `createAsyncThunk` __will always return a resolved promise__ with either the `fulfilled` action object or `rejected` action object inside, as appropriate.

The calling logic may wish to treat these actions as if they were the original promise contents. The promise returned by the dispatched thunk has an `unwrap` property which can be called to extract the `payload` of a `fulfilled` action or to throw either the `error` or, if available, `payload` created by `rejectWithValue` from a `rejected` action:

~~~
// in the component

const onClick = async () => {
  try {
    const originalPromiseResult = await dispatch(fetchUserById(userId)).unwrap()
    // handle result here
  } catch (rejectedValueOrSerializedError) {
    // handle error here
  }
}
~~~

### Handling Thunk Errors

If you need to customize the contents of the `rejected` action, you should catch any errors yourself, and then return a new value using the `thunkAPI.rejectWithValue` utility. Doing return `rejectWithValue(errorPayload)` will cause the `rejected` action to use that value as `action.payload`.

The `rejectWithValue` approach should also be used if your API response "succeeds", but contains some kind of additional error details that the reducer should know about. This is particularly common when expecting field-level validation errors from an API.

~~~
const updateUser = createAsyncThunk(
  "users/update",
  async (userData, { rejectWithValue }) => {
    const { id, ...fields } = userData;
    try {
      const response = await userAPI.updateById(id, fields);
      return response.data.user;
    } catch (err) {
      // Use `err.response.data` as `action.payload` for a `rejected` action,
      // by explicitly returning it using the `rejectWithValue()` utility
      return rejectWithValue(err.response.data);
    }
  }
);
~~~

### Cancellation

#### Canceling Before Execution

If you need to cancel a thunk before the payload creator is called, you may provide a condition `callback` as an option after the payload creator. The callback will receive the thunk argument and an object with `{ getState, extra }` as parameters, and use those to decide whether to continue or not. If the execution should be canceled, the `condition` callback should return a literal `false` value or a promise that should resolve to `false`. If a promise is returned, the thunk waits for it to get fulfilled before dispatching the `pending` action, otherwise it proceeds with dispatching synchronously.

~~~
const fetchUserById = createAsyncThunk(
  "users/fetchByIdStatus",
  async (userId: number, thunkAPI) => {
    const response = await userAPI.fetchById(userId);
    return response.data;
  },
  {
    condition: (userId, { getState, extra }) => {
      const { users } = getState();
      const fetchStatus = users.requests[userId];
      if (fetchStatus === "fulfilled" || fetchStatus === "loading") {
        // Already fetched or in progress, don't need to re-fetch
        return false;
      }
    },
  }
);
~~~

If `condition()` returns `false`, the default behavior is that no actions will be dispatched at all. If you still want a "rejected" action to be dispatched when the thunk was canceled, pass in `{ condition, dispatchConditionRejection: true }`.

#### Canceling While Running

If you want to cancel your running thunk before it has finished, you can use the abort method of the promise returned by `dispatch(fetchUserById(userId))`.

A real-life example of that would look like this:

~~~
// file: store.ts noEmit
import { configureStore } from "@reduxjs/toolkit";
import type { Reducer } from "@reduxjs/toolkit";
import { useDispatch } from "react-redux";

declare const reducer: Reducer<{}>;
const store = configureStore({ reducer });
export const useAppDispatch = () => useDispatch<typeof store.dispatch>();

// file: slice.ts noEmit
import { createAsyncThunk } from "@reduxjs/toolkit";
export const fetchUserById = createAsyncThunk(
  "fetchUserById",
  (userId: string) => {
    /* ... */
  }
);

// file: MyComponent.ts
import { fetchUserById } from "./slice";
import { useAppDispatch } from "./store";
import React from "react";

function MyComponent(props: { userId: string }) {
  const dispatch = useAppDispatch();
  React.useEffect(() => {
    // Dispatching the thunk returns a promise
    const promise = dispatch(fetchUserById(props.userId));
    return () => {
      // `createAsyncThunk` attaches an `abort()` method to the promise
      promise.abort();
    };
  }, [props.userId]);
}
~~~
