# ?Strict mode

_StrictMode_ — инструмент для обнаружения потенциальных проблем в приложении.

Также как и `Fragment`, `StrictMode` не рендерит видимого UI. Строгий режим активирует дополнительные проверки и предупреждения для своих потомков.

Проверки строгого режима работают только в режиме разработки; они не оказывают никакого эффекта в продакшен-сборке.

Строгий режим может быть включён для любой части приложения.

На данный момент `StrictMode` помогает в:

* __Обнаружении небезопасных методов жизненного цикла.__

Некоторые из устаревших жизненных циклов компонентов, как правило, поощряют небезопасные методы кодирования. Это `componentWillMount`, `componentWillReceiveProps`, `componentWillUpdate`. К ним добавлен префикс `«UNSAFE_»`. (Здесь «небезопасный» относится не к безопасности, а вместо этого означает, что код, использующий эти жизненные циклы, с большей вероятностью будет содержать ошибки в будущих версиях React, особенно после включения асинхронного рендеринга.)

* __Предупреждении об использовании устаревшего API строковых реф.__

Поскольку объекты-рефы стали заменой строковых реф, строгий режим теперь предупреждает об использовании строковых реф.

* __Предупреждении об использовании устаревшего метода `findDOMNode`.__

Ранее React использовал `findDOMNode` для поиска DOM-узла в дереве по указанному экземпляру класса. В большинстве случаев этот метод не используется, поскольку можно привязать реф непосредственно к DOM-узлу.

`findDOMNode` может использоваться для классовых компонентов, однако это нарушает уровни абстракции, позволяя родительскому компоненту требовать, чтобы происходил рендер определённых дочерних элементов.

Если дочерний компонент возвращает `null`, то ошибка. Это приводит к проблемам при рефакторинге, когда не удаётся изменить детали реализации компонента, так как родитель может использовать DOM-узел этого компонента.

`findDOMNode` возвращает только первый дочерний элемент, но с использованием фрагментов компонент может рендерить несколько DOM-узлов.

`findDOMNode` выполняет поиск только один раз. Затем метод возвращает ранее полученный результат при вызове. Если дочерний компонент рендерит другой узел, то это изменение никак не отследить. Поэтому `findDOMNode` работает, только когда компоненты возвращают единственный и неизменяемый DOM-узел.

* __Обнаружении неожиданных побочных эффектов.__

Строгий режим не способен автоматически обнаруживать побочные эффекты (утечки памяти и недопустимое состояние приложения), но помогает их отследить, сделав более детерминированными (алгоритмический процесс, который выдаёт уникальный и предопределённый результат для заданных входных).

Такое поведение достигается путём двойного вызова следующих методов:

1. Методы `constructor`, `render`, и `shouldComponentUpdate` классового компонента.
2. Статический метод классового компонента `getDerivedStateFromProps`.
3. Тело функционального компонента.
4. Функции обновления (первый аргумент `setState`).
5. Функции, переданные в `useState`, `useMemo` или `useReducer`.

Это применимо только в режиме разработки. Методы жизненного цикла не вызываются дважды в продакшен-режиме.

Но если метод не является идемпотентным (действие, многократное повторение которого эквивалентно однократному), тогда создание этого компонента несколько раз может привести к недопустимому состоянию приложения.

Такие труднонаходимые ошибки могут никак не проявить себя во время разработки или быть настолько редкими, что останутся незамеченными.

Двойной вызов таких методов, как конструктор компонента, позволяет строгому режиму легко обнаружить подобные проблемы.

Начиная с React 18, React не подавляет логирование. Однако, если у вас установлен `React DevTools`, логи второго вызова будут немного затемнены. `React DevTools` также предлагает настройку (по умолчанию отключена) для их полного подавления.

* __Обнаружении устаревшего API контекста.__

* __Обеспечение переиспользованного состояния.__

В будущем будет добавлена функция, которая позволяет React добавлять и удалять разделы пользовательского интерфейса с сохранением состояния. Например, когда пользователь переходит от экрана к экрану и обратно, React должен иметь возможность немедленно отображать предыдущий экран.

Для этого React поддерживает повторное монтирование деревьев с использованием того же состояния компонента, которое использовалось до размонтирования.

Эта функция позволит React повысить производительность «из коробки» (изначально готовому к использованию), но требует, чтобы компоненты были устойчивы к многократному монтированию и уничтожению эффектов.

Большинство эффектов будут работать без каких-либо изменений, но некоторые эффекты неправильно очищают подписки в функции обратного вызова или подразумевают, что они монтируются или уничтожаются только один раз.

~~~
function App() {
  const ref = useRef<string | null>(null);

  if (ref.current === null) {
    ref.current = "ref";
  }

  console.log("render");

  useEffect(() => {
    // ref.current = "ref"; // чтобы исправить добавляем эту строчку
    console.log(ref.current);
    return () => {
      ref.current = null;
    };
  }, []);

  return <p>{ref.current}</p>;
}
~~~

Чтобы помочь устранить эти проблемы, React 18 представляет новую проверку только в режиме разработки в строгом режиме. Эта новая проверка автоматически размонтирует и перемонтирует каждый компонент всякий раз, когда компонент монтируется в первый раз, восстанавливая предыдущее состояние при втором монтировании.

Размонтирование и повторное монтирование включает в себя:

1. `componentDidMount`
2. `componentWillUnmount`
3. `useEffect`
4. `useLayoutEffect`
5. `useInsertionEffect`

Это относится только к режиму разработки, для продакшена поведение остаётся неизменным.
