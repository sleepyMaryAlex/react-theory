# ?Reconciliation

Здесь объясняются решения, принятые для алгоритма сравнения в React, которые делают обновления компонента предсказуемыми, и в то же время достаточно быстрыми для высокопроизводительных приложений.

При работе с React мы понимаем `render()` как функцию, которая создаёт дерево React-элементов в какой-то момент времени. React реализует эвристический алгоритм сравнения `O(n)`, который основывается на двух утверждениях:

1. Два элемента с разными типами (тегами) произведут разные деревья.
2. Разработчик может указать какие дочерние элементы останутся стабильными между рендерами с помощью пропа `key`.

### Элементы различных типов

Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля. Трансформация из `<a>` в `<img>` приведет к полному перестроению вложенных элементов. При уничтожении дерева старые DOM-узлы удаляются. Экземпляры компонента получают `componentWillUnmount()` (не когда просто тег меняется, а компонент). При построении нового дерева, новые DOM-узлы вставляются в DOM. Экземпляры компонента получают `componentDidMount()`. Любое состояние, связанное со старым деревом, теряется.

~~~
function App() {
  const [update, setUpdate] = useState(false);

  return (
    <div className="Parent">
      {update ? <section>Section Element</section> : <p>Paragraph Element</p>}
      <button onClick={() => setUpdate((prev) => !prev)}>Update</button>
    </div>
  );
}
~~~

В примере выше обратите внимание, как элемент, а также его родитель перерисовываются, когда мы меняем состояние при нажатии кнопки. При переключении состояния мы меняем тип самого элемента (с `section` на `p`), и в соответствии с алгоритмом сравнения React уничтожает старое дерево и создает новое из корня/родителя измененного элемента.

Любые компоненты, лежащие ниже корневого, также размонтируются, а их состояние уничтожится. Например, это произойдёт при таком сравнении. При этом старый `Counter` уничтожится и смонтируется новый:

~~~
<div>
  <Counter />
</div>

<span>
  <Counter />
</span>
~~~

### DOM-элементы одного типа

При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты. Например:
~~~
<div className="before" title="stuff" />
~~~

~~~
<div className="after" title="stuff" />
~~~

Сравнивая эти элементы, React знает, что нужно модифицировать только `className` у DOM-узла.
Обновляя `style`, React также знает, что нужно обновлять только изменившиеся свойства. При конвертации между этими элементами, React знает, что нужно модифицировать только стиль `color`, не затронув `fontWeight`.

После обработки DOM-узла React рекурсивно проходит по дочерним элементам, т.е. продолжает смотреть изменения.

### Текстовые узлы

Пример:

~~~
function App() {
  const [update, setUpdate] = useState(false);

  return (
    <div className="Parent">
      {update ? <p>New Paragraph</p> : <p>Old Paragraph</p>}
      <button onClick={() => setUpdate((prev) => !prev)}>Update</button>
    </div>
  );
}
~~~

В консоли во вкладке `Elements` мы видим, что в этом случае перерисовывается только элемент, а не его родитель, поскольку мы не меняем тип элемента (`<p>` остается как `<p>`).

### Компоненты одного типа

Когда компонент обновляется, его экземпляр остаётся прежним, поэтому его состояние сохраняется между рендерами. React обновляет пропсы базового экземпляра компонента для соответствия новому элементу и вызывает `componentDidUpdate()` на базовом экземпляре.
Далее вызывается метод `render()` и алгоритм сравнения рекурсивно обходит предыдущий и новый результаты.

### Обновление без `key`

~~~
function App() {
  const [itemList, setItemList] = useState<number[]>([]);

  return (
    <div className="Parent">
      {itemList.map((item) => (
        <li>{item}</li>
      ))}
      <button onClick={() => setItemList((prev) => [+new Date(), ...prev])}>
        Add
      </button>
    </div>
  );
}
~~~

Обратите внимание, как перерисовываются все элементы родственного списка, когда мы добавляем новый элемент в начало списка. Это связано с тем, что мы не предоставили никакой `key` поддержки. При добавлении элемента родительский `div` не перерисовывается.

### Обновление с `key`

~~~
function App() {
  const [itemList, setItemList] = useState<number[]>([]);

  return (
    <div className="Parent">
      {itemList.map((item) => (
        <li key={item}>{item}</li>
      ))}
      <button onClick={() => setItemList((prev) => [+new Date(), ...prev])}>
        Add
      </button>
    </div>
  );
}
~~~

Здесь мы дали уникальный идентификатор каждому элементу в виде `key`, поэтому во время сравнения React может различать каждый элемент и, следовательно, повторно отображает только тот элемент, который был изменен (1-ый элемент).

### Дополнительно

Вот еще пример, в котором перерисовывается только `span`, когда он появляется, и только родительский `div`, когда `span` исчезает. И это благодаря тому, что указаны `key`. В противном случае перерисовывались бы все сиблинги + родительский `div`.

~~~
function App() {
  const [update, setUpdate] = useState(false);

  return (
    <div className="Parent">
      {update ? (
        <div>
          <span>SPAN</span>
          <h2 key="h2">H2</h2>
          <p key="p">P</p>
        </div>
      ) : (
        <div>
          <h2 key="h2">H2</h2>
          <p key="p">P</p>
        </div>
      )}
      <button onClick={() => setUpdate((prev) => !prev)}>Update</button>
    </div>
  );
}
~~~

Но такой пример мало где можно встретить. Вместо этого часто делают так:

~~~
function App() {
  const [update, setUpdate] = useState(false);

  return (
    <div className="Parent">
      <div>
        {update && <span>SPAN</span>}
        <h2>H2</h2>
        <p>P</p>
      </div>

      <button onClick={() => setUpdate((prev) => !prev)}>Update</button>
    </div>
  );
}
~~~

И это работает без `key`. Когда `span` появляется, перерисовывается только `span`. Когда `span` исчезает, перерисовывается родительский `div`.

### Компромисы

Важно помнить, что алгоритм согласования — это деталь реализации. React может повторно рендерить всё приложение на каждое действие, конечный результат будет тем же.

Для ясности, повторный рендер в этом контексте означает вызов функции `render` для всех компонентов, но это не означает, что React размонтирует и смонтирует их заново. Он лишь применит различия следуя правилам, которые были обозначены выше.

~~~
class App extends React.Component<object, { isTrue: boolean }> {
  constructor(props: object) {
    super(props);
    this.state = {
      isTrue: false,
    };
  }

  componentDidMount(): void {
    console.log("mount");
  }

  componentWillUnmount(): void {
    console.log("unmount");
  }

  render() {
    console.log("render");
    return this.state.isTrue ? (
      <div className="Parent">
        <button onClick={() => this.setState({ isTrue: !this.state.isTrue })}>
          Add
        </button>
      </div>
    ) : (
      <section className="Parent">
        <button onClick={() => this.setState({ isTrue: !this.state.isTrue })}>
          Add
        </button>
      </section>
    );
  }
}
~~~

В примере выше рендерится все приложение, у `App` вызывается метод `render`, но React не вызывает `componentDidMount` и `componentWillUnmount`.
