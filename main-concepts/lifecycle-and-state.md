# ?Lifecycle and state

## Lifecycle and state. Example

~~~
class Clock extends React.Component<object, { date: Date }> {
  timerID: NodeJS.Timeout | undefined;
  constructor(props: object) {
    super(props);
    this.state = {
      date: new Date()
    };
  }

  componentDidMount() {
    this.timerID = setInterval(
      () => this.tick(),
      1000
    );
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({
      date: new Date()
    });
  }

  render() {
    return (
      <div>
        <h1>Привет, мир!</h1>
        <h2>Сейчас {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
~~~

Обратите внимание, что мы передаём `props` базовому (родительскому) конструктору.

Классовые компоненты всегда должны вызывать базовый конструктор с аргументом `props`.

Первоначальный рендеринг компонента в DOM называется «монтирование» (_mounting_). Нам нужно устанавливать таймер всякий раз, когда это происходит.

Каждый раз когда DOM-узел, созданный компонентом, удаляется, происходит «размонтирование» (_unmounting_). Чтобы избежать утечки ресурсов, мы будем сбрасывать таймер при каждом «размонтировании» (В приложениях со множеством компонентов очень важно освобождать используемые системные ресурсы, когда компоненты удаляются).

Метод `render` будет вызываться каждый раз, когда происходит обновление.

Метод `componentDidMount()` запускается после того, как компонент отрендерился в DOM.

Поля `this.props` и `this.state` в классах — особенные, и их устанавливает сам React. Вы можете вручную добавить новые поля, если компоненту нужно хранить дополнительную информацию (например, ID таймера).

Мы сбрасываем таймер в методе жизненного цикла `componentWillUnmount()`.

`this.setState()` обновляет внутреннее состояние компонента.

Порядок, в котором вызываются методы:

1. Когда мы передаём `<Clock />` в `root.render()`, React вызывает конструктор компонента.
2. React вызывает метод `render()` компонента `Clock`.
3. React вызывает метод жизненного цикла `componentDidMount()`.
4. Таймер вызывает `tick()` ежесекундно. Внутри `tick()` мы просим React обновить состояние компонента, вызывая `setState()` с текущим временем. React реагирует на изменение состояния и снова запускает `render()`.
5. Если компонент `Clock` когда-либо удалится из DOM, React вызовет метод жизненного цикла `componentWillUnmount()` и сбросит таймер.

Три детали о правильном применении `setState()`:

1. Не изменяйте состояние напрямую. Потому что не произойдет повторного рендера. Вместо этого используйте `setState()`. Конструктор — это единственное место, где вы можете присвоить значение `this.state` напрямую.
2. Обновления состояния могут быть асинхронными. React может сгруппировать несколько вызовов `setState()` в одно обновление для улучшения производительности. Поскольку `this.props` и `this.state` могут обновляться асинхронно, вы не должны полагаться на их текущее значение для вычисления следующего состояния.

Например, следующий код может не обновить счётчик:

~~~
this.setState({
  counter: this.state.counter + this.props.increment,
});
~~~

Правильно будет использовать второй вариант вызова `setState()`, который принимает функцию, а не объект.

~~~
this.setState((state, props) => ({
  counter: state.counter + props.increment
}));
~~~

3. Обновления состояния объединяются. Например, состояние может состоять из нескольких независимых полей. `setState()` автоматически производит слияние части состояния с текущим состоянием, то есть нам нужно передать в него только ту часть `state`, которую хотим изменить.

### What is the difference between props and state?

«Состояние» очень похоже на пропсы, отличие в том, что состояние контролируется и доступно только конкретному компоненту.

### Unidirectional data flow

В иерархии компонентов ни родительский, ни дочерние компоненты не знают, задано ли состояние другого компонента. Также не важно, как был создан определённый компонент — с помощью функции или с помощью класса.

Состояние часто называют «локальным», «внутренним» или инкапсулированным. Оно доступно только для самого компонента и скрыто от других.

Компонент может передать своё состояние вниз по дереву в виде пропсов дочерних компонентов. Это, в общем, называется «нисходящим» («top-down») или «однонаправленным» («unidirectional») потоком данных. Состояние всегда принадлежит определённому компоненту, а любые производные этого состояния могут влиять только на компоненты, находящиеся «ниже» в дереве компонентов.

Все компоненты действительно изолированы. Даже если мы отрендерим компонент `Clock` три раза, у каждого компонента `Clock` будет собственное состояние таймера, которое будет обновляться независимо от других компонентов.

В React-приложениях, имеет ли компонент состояние или нет — это внутренняя деталь реализации компонента, которая может меняться со временем. Можно использовать компоненты без состояния в компонентах с состоянием, и наоборот.

### How does state in a class component differ from state in a functional component?

Состояние в компоненте класса принадлежит экземпляру класса (`this`) и инициализируется вместе с классом в функции-конструкторе. В функциональном компоненте хук `useState` вызывается каждый раз, когда компонент выполняет рендеринг, и возвращает состояние, запомненное React под капотом.

### What is the component lifecycle?

Компоненты React имеют 4 отдельные фазы «жизни»:

* Сначала компонент _инициализируется_ и _монтируется_ в DOM.
* Со временем компонент _обновляется_.
* В итоге компонент _размонтируется_ или удаляется из DOM.

### How do you update lifecycle in function components?

Использование `useEffect` хука!

Вы можете думать о `useEffect` хуке как о `componentDidMount`, `componentDidUpdate` и `componentWillUnmount` вместе взятых.
