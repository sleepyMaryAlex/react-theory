# ?Lists and keys

~~~
function NumberList(props: { numbers: number[] }) {
  const listItems = props.numbers.map((number) =>
    <li key={number.toString()}>{number}</li>
  );

  return (
    <ul>{listItems}</ul>
  );
}
~~~

У каждого элемента массива должен быть ключ (`key`). «Ключ» — это специальный строковый атрибут, который нужно указывать при создании списка элементов.

Ключи помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени.

Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи.

Когда у вас нет заданных ID для списка, то в крайнем случае можно использовать индекс элемента как ключ. Не рекомендуется использовать индексы как ключи, если порядок элементов может поменяться. Это негативно скажется на производительности и может вызвать проблемы с состоянием компонента.

Если вы опустите ключ для элемента в списке, то React по умолчанию будет использовать индексы как ключи.

Как правило, элементам внутри `map()` нужны ключи. Ключи внутри массива должны быть уникальными только среди своих соседних элементов. Им не нужно быть уникальными глобально. Можно использовать один и тот же ключ в двух разных массивах.

Ключи служат подсказками для React, но они никогда не передаются в ваши компоненты.

В примере выше мы отдельно определяли переменную `listItems` и вставляли её в JSX. JSX позволяет встроить любое выражение в фигурные скобки, так что мы можем включить результат выполнения `map()`:

~~~
function NumberList(props: { numbers: number[] }) {
  return (
    <ul>
      {props.numbers.map((number) =>
        <li key={number.toString()}>{number}</li>
      )}
    </ul>
  );
}
~~~

Иногда это приводит к более чистому коду, но бывает и наоборот. Как и в любом JavaScript-коде, вам придётся самостоятельно решать, стоит ли извлекать код в переменную ради читабельности.

### Is it a good idea to use `Math.random` for keys?

Ключи должны быть стабильными, предсказуемыми и уникальными. Нестабильные ключи (например, произведённые с помощью `Math.random()`) вызовут необязательное пересоздание многих экземпляров компонента и DOM-узлов, что может вызывать ухудшение производительности и потерю состояния у дочерних компонентов.

Ниже будет пример, который также можно попробовать и с `Math.random()`.

В идеале ключи должны соответствовать уникальным и стабильным идентификаторам, исходящим из ваших данных, например `id`.

React рекомендует не использовать индексы в качестве ключей, поскольку это может негативно сказаться на производительности и привести к нестабильному поведению компонентов. Ниже пример, почему индексы в качестве ключей могут приводить к ошибкам:

App.tsx
~~~
function App() {
  const [list, setList] = useState<{ name: string; id: number }[]>([
    { name: "Foo1444610101010", id: 1444610101010 },
    { name: "Bar1444600000000", id: 1444600000000 },
  ]);

  function addItem() {
    const id = +new Date();
    setList([{ name: "Baz" + id, id }, ...list]);
  }

  return (
    <div>
      <button onClick={addItem}>Add item</button>

      <h3>
        Dangerous <em>key=index</em>
      </h3>
      <form>
        {list.map((todo, index) => (
          <Item {...todo} key={index} />
        ))}
      </form>

      <h3>
        Better <em>key=id</em>
      </h3>
      <form>
        {list.map((todo) => (
          <Item {...todo} key={todo.id} />
        ))}
      </form>
    </div>
  );
}
~~~

Item.tsx
~~~
function Item(props: { name: string; id: number }) {
  return (
    <div>
      <label htmlFor="input">{props.name}</label>
      <input id="input" type="text" />
    </div>
  );
}
~~~
