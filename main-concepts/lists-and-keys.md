# ?Lists and keys

~~~
function NumberList(props: { numbers: number[] }) {
  const listItems = props.numbers.map((number) =>
    <li key={number.toString()}>{number}</li>
  );

  return (
    <ul>{listItems}</ul>
  );
}
~~~

У каждого элемента массива должен быть ключ (`key`). «Ключ» — это специальный строковый атрибут, который нужно указывать при создании списка элементов.

Ключи помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени.

Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи.

Когда у вас нет заданных ID для списка, то в крайнем случае можно использовать индекс элемента как ключ. Не рекомендуется использовать индексы как ключи, если порядок элементов может поменяться. Это негативно скажется на производительности и может вызвать проблемы с состоянием компонента.

Если вы опустите ключ для элемента в списке, то React по умолчанию будет использовать индексы как ключи.

Как правило, элементам внутри `map()` нужны ключи. Ключи внутри массива должны быть уникальными только среди своих соседних элементов. Им не нужно быть уникальными глобально. Можно использовать один и тот же ключ в двух разных массивах.

Ключи служат подсказками для React, но они никогда не передаются в ваши компоненты.

В примере выше мы отдельно определяли переменную `listItems` и вставляли её в JSX. JSX позволяет встроить любое выражение в фигурные скобки, так что мы можем включить результат выполнения `map()`:

~~~
function NumberList(props: { numbers: number[] }) {
  return (
    <ul>
      {props.numbers.map((number) =>
        <li key={number.toString()}>{number}</li>
      )}
    </ul>
  );
}
~~~

Иногда это приводит к более чистому коду, но бывает и наоборот. Как и в любом JavaScript-коде, вам придётся самостоятельно решать, стоит ли извлекать код в переменную ради читабельности.
