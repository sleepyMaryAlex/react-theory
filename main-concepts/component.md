# ?Component

Приложения React состоят из компонентов. _Компонент_ — это часть UI (пользовательского интерфейса), которая имеет собственную логику и внешний вид. Компонент может быть маленьким, как кнопка, или большим, как целая страница.

_Компонент_ -  функция, которая принимает  «пропсы» и возвращает разметку JSX.

### Functional and class components

С точки зрения React, эти два компонента эквивалентны:

~~~
function Welcome(props) {
  return <h1>Привет, {props.name}</h1>;
}
~~~

~~~
class Welcome extends React.Component {
  render() {
    return <h1>Привет, {this.props.name}</h1>;
  }
}
~~~

Компоненты могут иметь внутри себя другие компоненты. Можно переиспользовать компоненты.

В приложениях, написанных на React с нуля, как правило, есть один компонент `App`, который находится на самом верху.

В случае, если вы переписываете существующее приложение на React, имеет смысл начать работу с маленького компонента типа `Button` и постепенно двигаться «вверх» по иерархии.

Если какая-то часть интерфейса многократно в нём повторяется (`Button`, `Panel`, `Avatar`) или сама по себе достаточно сложная (`App`, `FeedStory`, `Comment`), имеет смысл её вынести в независимый компонент.

Имена компонентов React всегда должны начинаться с заглавной буквы, а теги HTML должны быть строчными.

Ключевые слова `export default` определяют главный компонент в файле.

### Сохранение компонентов в чистоте

Чистая функция — это функция со следующими характеристиками:

* Она не изменяет какие-либо объекты или переменные, существовавшие до его вызова.
* При одних и тех же входных данных чистая функция всегда должна возвращать один и тот же результат.

React разработан вокруг этой концепции. React предполагает, что каждый написанный вами компонент является чистой функцией.

Процесс рендеринга React всегда должен быть чистым.

Вот компонент, который нарушает это правило:

~~~
function Cup() {
  // Bad: changing a preexisting variable!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}
~~~

Мы можем исправить этот компонент:

~~~
function Cup({ guest }: { guest: number }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup guest={1} />
      <Cup guest={2} />
      <Cup guest={3} />
    </>
  );
}
~~~

Теперь наш компонент чистый, так как возвращаемый им JSX зависит только от `guest`.

В общем, мы не должны ожидать, что наши компоненты будут отображаться в каком-то определенном порядке.

Это часто называют «мутацией».

Однако совершенно нормально изменять переменные и объекты, которые вы только что создали во время рендеринга.

~~~
function Cup({ guest }: { guest: number }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaGathering() {
  let cups = [];
  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />);
  }
  return cups;
}
~~~

Это называется «локальной мутацией» — это что-то вроде маленького секрета вашего компонента.

В React побочные эффекты обычно принадлежат обработчикам событий. Обработчики событий — это функции, которые React запускает, когда вы выполняете какое-либо действие, например, когда вы нажимаете кнопку.

Несмотря на то, что обработчики событий определены внутри вашего компонента, они не запускаются во время рендеринга! Таким образом, обработчики событий не должны быть чистыми.

Если вы исчерпали все другие варианты и не можете найти правильный обработчик событий для вашего побочного эффекта, вы все равно можете прикрепить его к возвращенному JSX с помощью вызова `useEffect` в своем компоненте. Это говорит React выполнить его позже, после рендеринга, когда разрешены побочные эффекты. Тем не менее, этот подход должен быть вашим последним средством.
